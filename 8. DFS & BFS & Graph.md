# DFS

### 例1. [luogu-P1706](https://www.luogu.com.cn/problem/P1706)

DFS 算法:

```c++
#include <bits/stdc++.h>
using namespace std;

int n;
unordered_set<int> visited;
vector<int> ans;
void dfs()
{
    if (ans.size() == n)
    {
        for (auto num : ans)
            printf("%5d", num);
        printf("\n");
        return;
    }

    for (int i = 1; i <= n; i++)
    {
        if (visited.find(i) != visited.end())
            continue;
        ans.push_back(i);
        visited.insert(i);
        dfs();
        ans.pop_back();
        visited.erase(i);
    }
}

int main()
{
    scanf("%d", &n);
    dfs();

    return 0;
}
```

使用 `next_permutation()` 函数:

```c++
#include <bits/stdc++.h>
using namespace std;


vector<int> ans;
void printNum()
{
    for (auto num : ans)
        printf("%5d", num);
    printf("\n");
}

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        ans.push_back(i);

    do {
        printNum();
    } while (next_permutation(ans.begin(), ans.end()));

    return 0;
}
```

# BFS

用队列实现.

# 图

详见数据结构.

## 邻接矩阵

对于有 $m$ 个顶点的图, 可开一个 $m \times m$ 的二维数组.

## 邻接表

对于有 $m$ 个顶点的图, 可以开一个 `vector<vector<int>> vertexes(m)`, 那么对于顶点 $v_i$, 可以将与其通过边相连的顶点放入 `vertexes[i - 1]` 中. 对于有权图, 可以将此改为结构体.

### 例2. [luogu-P3916](https://www.luogu.com.cn/problem/P3916)

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAXSIZE = 100010;
int N, M;
vector<int> v[MAXSIZE];
int ans[MAXSIZE];

void dfs(int vertex, int d)
{
    if (ans[vertex] != 0)
        return;
    ans[vertex] = d;
    for (int ver : v[vertex])
        dfs(ver, d);
}

int main()
{
    cin >> N >> M;
    for (int i = 1; i <= M; i++)
    {
        int s, e;
        cin >> s >> e;
        v[e].push_back(s);
    }
    for (int i = N; i > 0; i--)
        dfs(i, i);
    for (int i = 1; i <= N; i++)
        cout << ans[i] << " ";

    return 0;
}
```

* 树是特殊的图, 可以用图的表示方法表示