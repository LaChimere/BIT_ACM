# 1. 整除

记 `a % b == 0` 为 $b|a$, 有如下性质:

* 若 $a|b$, 则有 $-a|b, a|-b, |a| \mid |b|$.

* 若 $a|b, b|c$, 则有 $a|c$.

* 若 $a|b, a|c$, 则有 $a|(bx + cy), x, y \in \mathbb{Z}$.

* 若 $a|b$, 则有 $am|(bm), m \in \mathbb{Z^*}$.

* 若 $a|b, b|a$, 则有 $|a| = |b|$.

* 若 $a|(bc)$, 且 $a$ 与 $c$ 互质, 则 $a|b$.

* 若 $a|b, a|c$, 且 $b$ 与 $c$ 互质, 则 $a|(bc)$.

* 若 $a|b, c \in \mathbb{Z}$, 则 $b|(ac)$.

* $\forall a, b > 0$, 存在唯一数对 $q, r$, 使 $a = bq + r, 0 \leqslant r < b$. (**带余除法定理**, 整除理论的基础)

* 若 $c|a, c|b$, 则称 $c$ 是 $a, b$ 的公因数. 若 $d$ 是 $a, b$ 的公因数, $d \geqslant 0$, 且 $d$ 可被 $a, b$ 的任意公因数整除, 则 $d$ 是 $a, b$ 的最大公因数. 若 $a, b$ 的最大公因数等于 $1$, 则称 $a, b$ 互素, 也称互质. 累次利用带余除法可以求出 $a, b$ 的最大公因数, 这种方法常称为辗转相除法, 又称欧几里得算法.

# 2. 模 ($\mathrm{mod}$)

当 `a % b == c % b`, 称 $a \equiv c \; (\mathrm{mod} \; b)$, 有性质如下:

* 取模运算: `a % p` ($a \; \mathrm{mod} \; p$), 表示 `a` 除以 `p` 的余数.

* 模 `p` 加法: `(a + b) % p == (a % p + b % p) % p`.

* 模 `p` 减法: `(a - b) % p == (a % p - b % p) % p`.

* 模 `p` 乘法: `(a * b) % p == ((a % p) * (b % p)) % p`.

* 幂模 `p`: $a ^ b \; \mathrm{mod} \; p = (a \; \mathrm{mod} \; p)^b \; \mathrm{mod} \; p$.

* 模运算满足结合律、交换律和分配律.

* 反身性: $a \equiv a \; (\mathrm{mod} \; m)$.

* 对称性: 若 $a \equiv b \; (\mathrm{mod} \; m)$, 则 $b \equiv a \; (\mathrm{mod} \; m)$.

* 传递性: 若 $a \equiv b \; (\mathrm{mod} \; m), b \equiv c \; (\mathrm{mod} \; m)$, 则 $a \equiv c \; (\mathrm{mod} \; m)$.

* 同余式相加: 若 $a \equiv b \; (\mathrm{mod} \; m), c \equiv d \; (\mathrm{mod} \; m)$, 则 $a + c \equiv b + d \; (\mathrm{mod} \; m)$.

* 同余式相乘: 若 $a \equiv b \; (\mathrm{mod} \; m), c \equiv d \; (\mathrm{mod} \; m)$, 则 $ac \equiv bd \; (\mathrm{mod} \; m)$.

# 3. 一些常见定理

## 3.1 欧拉定理

$\forall a, n \in \mathbb{N^+}$, 且 $a, n$ 互质, 有

$$
a^{\varphi(n)} \equiv 1 \; (\mathrm{mod} \; n).
$$

其中,

$$
\varphi(n) = n \prod_{i = 1}^{m} (1 - \frac{1}{p_i}), n \in \mathbb{Z^*},
$$

为欧拉函数, $p_1, p_2,\dots, p_m$ 为 $n$ 的所有质因数.

## 3.2 费马小定理

若 $p$ 是为质数, 且当 $a \in \mathbb{Z}$ 时, $a \; \mathrm{mod} \; p \neq 0$, 即 $gcd(a, p) = 1$, 有

$$
a ^ {p - 1} \equiv 1 \; (\mathrm{mod} \; p).
$$

## 3.3 $Lucas$ 定理

* 用于计算二项式系数 $\begin{pmatrix}
    m \\
    n
\end{pmatrix}$ 被质数 $p$ 除所得的余数.

对于 $m, n \in \mathbb{N}$ 及质数 $p$, 同余式

$$
\begin{pmatrix}
    m \\
    n
\end{pmatrix} \equiv \prod_{i = 0}^{k} \begin{pmatrix}
    m_i \\
    n_i
\end{pmatrix} \quad (\mathrm{mod} \; p)
$$

成立, 其中

$$
\begin{aligned}
    m &= m_{k} p^{k} + m_{k-1} p^{k-1} + \cdots + m_{1} p + m_{0}, \\
    n &= n_{k} p^{k} + n_{k-1} p^{k-1} + \cdots + n_{1} p + n_{0}
\end{aligned}
$$

是 $m, n$ 的 $p$ 进制展开. 当 $m < n$ 时, 二项式系数 $\begin{pmatrix}
    m \\
    n
\end{pmatrix} = 0$.

## 3.4 威尔逊定理

* 给出了一个自然数是否为质数的充分必要条件.

当且仅当 $p$ 为质数时, 

$$
(p - 1)! \equiv -1 \quad (\mathrm{mod} \; p).
$$

# 4. 欧几里得算法

```c++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

最小公倍数 `lcm(a, b)` 可由 `lcm(a, b) * gcd(a, b) == a * b` 得到.

# 5. 扩展欧几里得算法

* 扩展欧几里得算法解决这样一个问题: 给定两个非零整数 $a, b$, 求一组整数解 $x, y$, 使得 $ax + by = gcd(a, b)$ 成立.

在上述欧几里得算法的递归过程中, 对任意一层的 $a, b$ (这里的 $a, b$ 与最初调用 `gcd()` 函数的 $a, b$ 不同), 有一组整数解 $x_i, y_i$ 使得 $ax_i + by_i = gcd(a, b)$ 成立, 其再调用 `gcd(b, a % b)` 时, 有一组整数解 $x_{i + 1}, y_{i + 1}$ 满足 $bx_{i + 1} + (a \; \mathrm{mod} \; b)y_{i + 1} = gcd(b, a \; \mathrm{mod} \; b) = gcd(a, b)$. 故有

$$
ax_i + by_i = bx_{i + 1} + (a \; \mathrm{mod} \; b)y_{i + 1}.
$$

由其中 $a \; \mathrm{mod} \; b = a - \lfloor \frac{a}{b} \rfloor \cdot b$, 有

$$
\begin{cases}
    x_i = y_{i + 1} \\
    y_i = x_{i + 1} - \lfloor \frac{a}{b} \rfloor y_{i + 1},
\end{cases}
$$

其中 $a, b$ 是第 $i$ 层递归的 $a, b$.

```c++
int exGCD(int a, int b, int& x, int& y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    
    int g = exGCD(b, a % b, x, y);
    int temp = x;
    x = y;
    y = temp - a / b * y;
    return g;
}
```

# 6. 模意义下的逆元

当 $a \cdot x \equiv 1 \; (\mathrm{mod} \; n)$ 时, 可认为 $x$ 是 $a$ 在 $\mathrm{mod} \; n$ 意义下的逆元. 数 $a$ 在 $\mathrm{mod} \; n$ 的意义下不一定有逆元, $a$ 在 $\mathrm{mod} \; n$ 意义下逆元存在的充要条件是 $a$ 与 $n$ 互质.

# 7. [中国剩余定理](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86)

# 8. 素数

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAXSIZE = 105;
vector<int> primes;
vector<bool> isPrime(MAXSIZE, true);

void getPrimes()
{
    for (int i = 2; i < MAXSIZE; i++)
    {
        if (isPrime[i])
        {
            primes.push_back(i);
            for (int j = i + i; j < MAXSIZE; j += i)
                isPrime[j] = false;
        }    
    }
}
```

# 9. 唯一分解定理

对所有大于 $1$ 的自然数, 要么本身即为质数, 要么可写为 $2$ 个或以上质数的积, 且这些质因子按大小排列之后, 写法只有一种方式.

定义:

$$
\forall A \in \mathbb{N}, A > 1, \exist \prod_{i = 1}^{n} {p_i}^{a_i} = A, 其中 p_1 < p_2 < \cdots < p_n, 且 p_i 为质数, a_i \in \mathbb{N^+},
$$

这种表示方法存在且唯一.