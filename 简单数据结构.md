# 1. 前缀和

对于数组 `A`, 其长度为 $n$, 令
$$
S[i] = \sum_{j = 0}^{i} A[j], 0 \leq i \leq n - 1
$$
则称 `S` 是 `A` 的前缀和. 前缀和有以下性质
$$
sum[l, r] = \sum_{i = l}^{r} A[i] = S[r] - S[l - 1].
$$

若令
$$
S[0] = A[0], S[i] = S[i - 1] \; {\rm{xor}} \; A[i], 0 \leq i \leq n - 1
$$
则称 `S` 是 `A` 的异或前缀和, 有以下性质
$$
sum[l, r] = A[l] \; {\rm{xor}} \; A[l + 1] \; {\rm{xor}} \; ... \; {\rm{xor}} \; A[r] = S[r] \; {\rm{xor}} \; S[l - 1].
$$

类似地, 有 `S` 满足
$$
S[i][j] = \sum_{p = 0}^{i} \sum_{q = 0}^{j} A[p][q], 0 \leq i \leq m - 1, 0 \leq j \leq n - 1
$$
则 `S` 是 `A` 的二维前缀和, 有以下性质
$$
S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + A[i][j],
$$
$$
sum[L_1, R_1, L_2, R_2] = S[L_2][R_2] - S[L_2][R_1] - S[L_1][R_2] + S[L_1][R_1].
$$

## 例题

### 1.1 给定 $A$ 数列, 长度为 $n$, 进行 $m$ 次询问, 每次询问 $L_i, R_i$, 求 $\sum_{j = L_i}^{R_i} A[j]$.

### 1.2 给定 $A$ 数列, 长度为 $n$, 先进行 $m$ 次修改, 再 $q$ 次询问. 每次修改为 $A$ 数组区间 $[L_i, R_i]$ 加某数 $x$, 即 `A[j] += x`, $j \in [L_i, R_i] \sube \rm{R}$. 每次询问 $L_i, R_i$, 求 $\sum_{j = L_i}^{R_i} A[j]$.

### 1.3 若数据个数 $n$ 很大, 应如何处理? (离散化)

# 2. 链表

举例如下

```c++
// 单链表结点
struct node {
    int data;
    node* next;
};

// 邻接表
struct edgeNode {
    int vertex, weight;
    edgeNode* next = nullptr;
    edgeNode(int _vertex, int _weight): vertex(_vertex), weight(_weight) {}
};
vector<edgeNode*> edges(vertexes.size(), nullptr);
```

# 3. 栈与队列

在C++ STL中可使用 `stack`, `queue`, `deque` 等进行栈和队列的操作.

注意: `pop()` 操作前要判断 `empty()` 是否为 `false`.

## 例题

### 3.1 括号匹配

### 3.2 有 $n$ 个人站队, 所有人向右看, 个子高的可以看到个子低的人的发型(高个子会挡住低个子的视线, 采用严格大于), 给出每个人的身高, 求所有人能看到其他人发型数量的总和.

> 输入: $4 \  3 \  7 \  1$
> 
> 输出: $2$
> 
> 解释: $4$ 能看到 $3$; $7$ 能看到 $1$.
>
> 输入: $3 \  4$
> 
> 输出: $0$

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    stack<int> height;
    int n;
    cin >> n;

    int cnt = 0;
    while (n--)
    {
        int h;
        cin >> h;
        while (!height.empty())
        {
            if (height.top() > h)
            {
                cnt += height.size();
                break;
            }
            else
                height.pop();
        }
        height.push(h);
    }
    cout << cnt << endl;

    return 0;
}
```

队列可用于 `BFS` 等算法.


# 4. 优先队列

