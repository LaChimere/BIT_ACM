# 状态与状态转移

### 例1. 数字三角形: 给出一个数字三角形, 从顶点出发每次向下或向右下走一步, 直至最底层, 将途经的数字相加, 得到最大值. 如,
$$
\begin{matrix}
    7 \\
    3 & 8 \\
    8 & 1 & 0 \\
    2 & 7 & 4 & 4 \\
    4 & 5 & 2 & 6 & 5
\end{matrix}
$$
解为 $7 \rightarrow 3 \rightarrow 8 \rightarrow 7 \rightarrow 5 = 30$.

> 定义状态 `dp[i][j]` 为从第 `1` 行第 `1` 列出发, 走到第`i` 行第 `j` 列所有路径的最大和. 有
> 
> `dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + matrix[i][j]`,
> 
> 其中, `dp[1][1] = matrix[1][1]` 且 $1 < i \leq n, 1 < j \leq i$. 则最终结果为 `dp[n][1...n]` 的最大值.

## 状态

明确两点:

* 初始状态. 如在例1中, 初始状态为 `dp[1][1] = matrix[1][1]`, `dp` 其余元素应初始化为一个合适的最小数, 如 `INT_MIN`.

* 答案选取位置. 如在例1中, 最终结果为 `max(dp[n][1...n])`.

## 状态转移

* 注意顺序, 要保证转移到当前状态的原状态已经处理完毕.

### 例2. 最长上升子序列( $LIS$ )

给定一个序列, 求其 $LIS$. 子序列定义: 将原序列删除 $0$ ~ $n$ 个元素所组成的序列. 子序列不一定是连续的元素.

> 令 `dp[i]` 表示以原序列下标为 `i` 结尾的上升子序列的最长长度. 取初始状态对所有 `i` 有 `dp[i] = 1`, 答案为 `max(dp[0...n - 1])`.
>
> 对下标为 `i` 的元素, 有 `j` 从 `0` 至 `i - 1` 依次更新
>
> `dp[i] = nums[j] <= nums[i] ? max(dp[i], dp[j] + 1) : dp[i]`.

* [最大连续子序列和](https://leetcode-cn.com/problems/maximum-subarray/)

* [最长公共子序列 ( $LCS$ )](https://leetcode-cn.com/problems/longest-common-subsequence/)

# 背包问题

详见 [背包九讲](背包九讲.pdf).

