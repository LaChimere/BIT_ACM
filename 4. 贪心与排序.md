# 贪心

### 例1. [luogu-P1181](https://www.luogu.com.cn/problem/P1181)

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;

    int cnt = 0, sum = 0;
    while (n--)
    {
        int num;
        cin >> num;

        sum += num;
        if (sum > m)
        {
            sum = num;
            cnt++;
        }
    }
    if (sum <= m)
        cnt++;

    cout << cnt;

    return 0;
}
```

## 贪心的注意事项

贪心的结果不一定正确, 要得到正确的结果, 需要保证贪心结果无后效性.

## 贪心 + 排序

### 例2. [luogu-P1090](https://www.luogu.com.cn/problem/P1090)

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;

    if (n == 1)
    {
        int weight;
        cin >> weight;
        cout << weight;
        return 0;
    }

    priority_queue<int, vector<int>, greater<int> > weights;
    while (n--)
    {
        int weight;
        cin >> weight;
        weights.push(weight);
    }

    int sum = 0;
    while (weights.size() > 1)
    {
        int w1 = weights.top();
        weights.pop();
        int w2 = weights.top();
        weights.pop();

        sum += w1 + w2;
        weights.push(w1 + w2);
    }

    cout << sum;

    return 0;
}
```

### **例3.** [**luogu-P1182**](https://www.luogu.com.cn/problem/P1182)

```c++
#include <bits/stdc++.h>
using namespace std;

int n, m;
const int MAXSIZE = 100005;
int s[MAXSIZE];

bool judge(int sum)
{
    int anchor = 0, cur, cnt = 0;
    for (cur = 1; cur <= n; cur++)
    {
        if (s[cur] - s[anchor] <= sum)
            continue;
        anchor = --cur;
        cnt++;
    }
    return cnt >= m;
}

int main()
{
    cin >> n >> m;

    int left = 0, right;
    for (int i = 1; i <= n; i++)
    {
        int num;
        cin >> num;
        s[i] = s[i - 1] + num;
        left = max(left, num);
    }
    right = s[n];

    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        if (judge(mid))
            left = mid + 1;
        else
            right = mid - 1;
    }

    cout << left;

    return 0;
}
```

