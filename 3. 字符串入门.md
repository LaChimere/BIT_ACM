# 基础约定与定义

* 记号 $\Sigma$ 表示字符集, 字符串中的字符一定在字符集内.

* $|s|$ 表示字符串 $s$ 的长度, $s[i] \  (0 \leq i < |s|)$ 表示字符串 $s$ 中的第 $(i + 1)$ 个字符.
  
  $s[l...r] \  (0 \leq l, r < |s|)$ 表示由串 $s$ 中下标为 $r$ 的字符所组成的子串. 特别地, 若 $l > r$, 则 $s[l...r]$ 为空串.

* 对于两个字符串 $s$ 和 $t$, 定义 $s$ 和 $t$ 相等(匹配)为:
  
  当且仅当 $|s| = |t|$, 且 $s[i] = t[i], 0 \leq i < |s|$.

* 记 $pre_s[i]$ 表示 $s[0...i]$, 称为 $s$ 的前缀 $i$; $suf_s[i]$ 表示 $s[i...|s| - 1]$, 称为 $s$ 的后缀 $i$.

* 对于两个串 $s$ 和 $t$, 定义 $LCP(s, t)$ 为 $s$ 与 $t$ 的最长公共前缀的长度.

# String Hash

## 常用字符串 $Hash$ 函数

在字符串匹配问题中, 常用如下函数作为字符串 $Hash$ 函数:
$$
Hash(s) = \sum_{i = 0}^{|s| - 1} s[i] \cdot p^i
$$
其中, $p$ 是一个常数, 且通常取质数. 该 $Hash$ 函数的优越性主要体现在其对子串 $Hash$ 的友好上.

定义 $Hash_s(i)$ 表示串 $s$ 的后缀 $i$ 的 $Hash$ 值, 则易知
$$
Hash_s(i) = 
\begin{cases}
  0, \qquad \qquad \qquad \qquad \quad i = |s| \\
  Hash_s(i + 1) \cdot p + s[i], 0 \leq i < |s|
\end{cases}
$$

定义 $Hash_s(i, L)$ 表示串 $s[i...i + L - 1]$ 的 $Hash$ 值, 则易知
$$
Hash_s(i, L) = Hash_s(i) - Hash_s(i + L) \cdot p^L
$$

在实际应用中, 常将 $Hash$ 值定义为 `unsigned long long` 型, 并在运算过程中令其自由溢出(相当于对 $2^{64} - 1$ 取模).

### 例题

#### 1. 给定一个模式串 $t$. 给定 $Q$ 组询问, 每组询问给定一个待匹配串 $s$. 对于每组询问, 分别回答给定的带匹配串 $s$ 是否包含串 $t$ 作为子串.

预处理串 $t$ 的 $Hash$ 值, 时间复杂度为 $O(t)$.

对于每个询问, 针对串 $s$ 中的每个长度为 $|t|$ 的子串, 计算其子串 $Hash$ 值并与模式串 $t$ 的 $Hash$ 值进行比较. 由于相邻子串间的子串 $Hash$ 值可以在 $O(1)$ 的时间复杂度内进行转移, 故该步骤的时间复杂度为 $O(Q|s|)$.

总体时间复杂度: $O(Q|s| + |t|)$.

#### 2. 小Q定义, 若两个字符串是相似的, 当且仅当这两个字符串等长且恰好只有 $1$ 位不同, 如 `"Penguin1"` 和 `"Penguin2"` 是相似的. 而小Q想知道, 在给定的 $N$ 个字符串中, 有多少对是相似的. 为了简化工作, 令 $N$ 个字符串长度均为 $L$, 只包含大小写字母和数字, 且不存在两个相同的字符串.