# 基础约定与定义

* 记号 $\Sigma$ 表示字符集, 字符串中的字符一定在字符集内.

* $|s|$ 表示字符串 $s$ 的长度, $s[i] \  (0 \leqslant i < |s|)$ 表示字符串 $s$ 中的第 $(i + 1)$ 个字符.
  
  $s[l...r] \  (0 \leqslant l, r < |s|)$ 表示由串 $s$ 中下标为 $r$ 的字符所组成的子串. 特别地, 若 $l > r$, 则 $s[l...r]$ 为空串.

* 对于两个字符串 $s$ 和 $t$, 定义 $s$ 和 $t$ 相等(匹配)为:
  
  当且仅当 $|s| = |t|$, 且 $s[i] = t[i], 0 \leqslant i < |s|$.

* 记 $pre_s[i]$ 表示 $s[0...i]$, 称为 $s$ 的前缀 $i$; $suf_s[i]$ 表示 $s[i...|s| - 1]$, 称为 $s$ 的后缀 $i$.

* 对于两个串 $s$ 和 $t$, 定义 $LCP(s, t)$ 为 $s$ 与 $t$ 的最长公共前缀的长度.

# String Hash

## 常用字符串 $Hash$ 函数

在字符串匹配问题中, 常用如下函数作为字符串 $Hash$ 函数:
$$
Hash(s) = \sum_{i = 0}^{|s| - 1} s[i] \cdot p^i
$$
其中, $p$ 是一个常数, 且通常取质数. 该 $Hash$ 函数的优越性主要体现在其对子串 $Hash$ 的友好上.

定义 $Hash_s(i)$ 表示串 $s$ 的后缀 $i$ 的 $Hash$ 值, 则易知
$$
Hash_s(i) = 
\begin{cases}
  0, \qquad \qquad \qquad \qquad \quad i = |s| \\
  Hash_s(i + 1) \cdot p + s[i], 0 \leqslant i < |s|
\end{cases}
$$

定义 $Hash_s(i, L)$ 表示串 $s[i...i + L - 1]$ 的 $Hash$ 值, 则易知
$$
Hash_s(i, L) = Hash_s(i) - Hash_s(i + L) \cdot p^L
$$

在实际应用中, 常将 $Hash$ 值定义为 `unsigned long long` 型, 并在运算过程中令其自由溢出(相当于对 $2^{64} - 1$ 取模).

### 例题

#### 1. 给定一个模式串 $t$. 给定 $Q$ 组询问, 每组询问给定一个待匹配串 $s$. 对于每组询问, 分别回答给定的带匹配串 $s$ 是否包含串 $t$ 作为子串.

预处理串 $t$ 的 $Hash$ 值, 时间复杂度为 $O(t)$.

对于每个询问, 针对串 $s$ 中的每个长度为 $|t|$ 的子串, 计算其子串 $Hash$ 值并与模式串 $t$ 的 $Hash$ 值进行比较. 由于相邻子串间的子串 $Hash$ 值可以在 $O(1)$ 的时间复杂度内进行转移, 故该步骤的时间复杂度为 $O(Q|s|)$.

总体时间复杂度: $O(Q|s| + |t|)$.

#### 2. 小Q定义, 若两个字符串是相似的, 当且仅当这两个字符串等长且恰好只有 $1$ 位不同, 如 `"Penguin1"` 和 `"Penguin2"` 是相似的, 但 `"Penguin1"` 和 `"2Penguin"` 不是相似的. 而小Q想知道, 在给定的 $N$ 个字符串中, 有多少对是相似的. 为了简化工作, 令 $N$ 个字符串长度均为 $L$, 只包含大小写字母和数字, 且不存在两个相同的字符串. 其中, $N \leqslant 30000, L \leqslant 200$.

枚举删除一位后, 利用子串的拼接计算出字符串的 $Hash$ 值. 时间复杂度为 $O(L \, (N + N \log N))$.


# 字典树(Trie)

字典树要解决的问题, 如:

给定一个字符串集合 $S$, 给定 $Q$ 个询问, 每个询问给定一个串 $t$. 对于每个询问, 要求回答给定的串 $t$ 是否为集合 $S$ 中某个字符串的前缀.

采用字典树的解法的时间复杂度为 $O(Q|t| + \Sigma_{s \in S}|S|)$.

## 字典树的特点

* 根节点到树上每个节点的路径上的字母构成这个节点代表的字符串(根节点代表空字符串).

* 叶子结点对应的字符串即为集合 $S$ 内的某个字符串.

* 因为字典树充分利用了集合 $S$ 中的字符串的公共前缀部分, 字典树的空间效率很高. 字典树的空间复杂度为 $O(\Sigma_{s \in S}|s|)$.

## 字典树代码

```c++
class TrieNode {
public:
    vector<TrieNode*> children = vector<TrieNode*>(26);

    TrieNode()
    {
        for (int i = 0; i < 26; i++)
            children[i] = nullptr;
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie()
    {
        this->root = new TrieNode();
    }

    void insert(const string& word)
    {
        TrieNode* cur = root;
        bool isNew = false;
        for (char i : word)
        {
            int c = i - 'a';
            if (cur->children[c] == nullptr)
            {
                isNew = true;
                cur->children[c] = new TrieNode();
            }
            cur = cur->children[c];
        }
    }
};
```


## 字典树上的一些符号约定

* 对于字典树上某结点 `p`, 记 `str(p)` 为从字典树根结点到结点 `p` 路径上的字符组成的字符串.

* 对于一字符串 `s`, 若 `s` 包含于字典树中, 记 `trienode(s)` 为串 `s` 在字典树上对应的结点.

* 对于一字符串 `s`, 若 `trienode(s)` 在字典树上某结点 `p` 的子树中, 称串 `s` 穿过结点 `p`.

易知, 若串 `s` 穿过结点 `p`, 则 `str(p)` 为 `s` 的前缀.

## 例题

### 1. 给定 $n$ 个数 $a_1, a_2,..., a_n$. 求 $\max \limits_{1 \leqslant i, j \leqslant n} \{a_i \; {\rm{xor}} \; a_j \}$.

二进制字典树. 时间复杂度: $O(\log \max \limits_{1 \leqslant i \leqslant n} a_i)$.

### 2. 给定 $n$ 个数 $a_1, a_2,..., a_n$. 求 $\max \limits_{1 \leqslant i \leqslant j \leqslant n} \{a_i \; {\rm{xor}} \; a_{i + 1} \; {\rm{xor}} \; ... \; {\rm{xor}} \; a_j \}$.

### 3. 给定若干个字符串, 所有字符串均不相同, 统计以某个字符串为前缀的单词数量(字符串本身是自己的前缀).