# 1. 二分法

* 思想简单, 重在实现

* 写法多样

* C++的 `<algorithm>` 头文件中有 `lower_bound()` 和 `upper_bound()` 可供使用

二分法可解决的问题举例:

* 具有单调性或连续性的问题的二分查找

* 最大最小问题, 二分答案

* 判断前缀的合法性, 二分前缀长度

* 分数规划问题, 二分答案

## 二分答案

* 适用情况: 求最值, 可能答案区间有限且单调, 检验答案的合理性复杂度低.

### 例1. 若一个数列中 $2k$ 个元素中, 前 $k$ 个元素的和与后 $k$ 个元素的和都不大于 $S$, 则称这些元素是"有趣"的. 现给定 $S$ 与一个长度为 $N$ 的数列, 求各个元素从本身开始能构成的最长有趣元素的长度.

### 例2. 有 $n$ 个牛栏, 分别位于 $x_1, x_2,..., x_n$, 选 $m$ 个放进牛, 使得相邻牛之间的最小距离最大. ( $m \leqslant n \leqslant 1 \times 10^5, 0 \leqslant x_i \leqslant 1 \times 10^9$ )

### 例3. 有 $n \times m$ 乘法表, 将 $n \times m$ 个数从小到大依次排列, 求第 $k$ 个数. ( $k \leqslant n, m \leqslant 5 \times 10^5$ )

# 2. 三分法*

* 适用于凸函数/凹函数.

以求最大值为例, 记 $t_{\rm{l}}, t_{\rm{r}}$ 分别为区间 $[left, right)$ 的左三等分点和右三等分点. 对比 $f(t_{\rm{l}})$ 与 $f(t_{\rm{r}})$.

若 $f(t_{\rm{l}}) < f(t_{\rm{r}})$, 则区间变为 $[t_{\rm{l}}, right)$, 否则区间变为 $[left, t_{\rm{r}})$.

# 3. 快速幂

### 例4. 求 $a^b \; \mathrm{mod} \; p$, 其中 $1 \leqslant a, b, p \leqslant 1 \times 10^9$.

将 $b$ 写成二进制, 有 $k$ 个有效位, 第 $i \; (0 \leqslant i < k)$ 位上的数字是 $c_i$, 则 $b$ 可表示为

$$
b = c_{k - 1}2^{k - 1} + c_{k - 2}2^{k - 2} + \dots + c_0 2^0
$$

故

$$
\begin{aligned}
    a^b &= a^{c_{k - 1}2^{k - 1} + c_{k - 2}2^{k - 2} + \dots + c_0 2^0} \\
    &= a^{c_{k - 1}2^{k - 1}} \cdot a^{c_{k - 2}2^{k - 2}} \cdot \dots \cdot a^{c_0 2^0}
\end{aligned}
$$

由此可写出快速幂算法如下:

```c++
int power(int a, int b, int p)
{
    int ans = 1 % p;
    while (b)
    {
        if (b & 1)
            ans = (long long)ans * a % p;
        a = (long long)a * a % p;
        b >>= 1;
    }
    return ans;
}
```

### 例5. 求 $a \cdot b \; \mathrm{mod} \; p$, 其中 $1 \leqslant a, b, p \leqslant 1 \times 10^{18}$.

同快速幂的思想, 将 $b$ 写成

$$
b = c_{k - 1}2^{k - 1} + c_{k - 2}2^{k - 2} + \dots + c_0 2^0
$$

则

$$
\begin{aligned}
    a \cdot b &= a \cdot (c_{k - 1}2^{k - 1} + c_{k - 2}2^{k - 2} + \dots + c_0 2^0) \\
    &= c_{k - 1} \cdot a 2^{k - 1} + c_{k - 2} \cdot a 2^{k - 2} + \dots + c_0 \cdot a 2^0
\end{aligned}
$$

由此可写出 64 位整数乘法的算法如下:

```c++
long long mul(long long a, long long b, long long p)
{
    long long ans = 0;
    while (b)
    {
        if (b & 1)
            ans = (ans + a) % p;
        a = a * 2 % p;
        b >>= 1;
    }
    return ans;
}
```

# 4. 矩阵快速幂

* 将快速幂中的底数变为矩阵

* 优势: 线性递推式

### 例6. 求 $Fibonacci$ 数列的第 $n$ 项. ( $0 \leqslant n < 1 \times 10^{18}$ )

由 $Fibonacci$ 数列的递推公式

$$
F_i =
\begin{cases}
    \begin{aligned}
        1, \quad i &= 0, 1 \\
        F_{i - 1} + F_{i - 2}, \quad i &> 1
    \end{aligned}
\end{cases}
$$

有

$$
\begin{pmatrix}
    F_i \\
    F_{i - 1}
\end{pmatrix} =
\begin{cases}
    \begin{aligned}
        \begin{pmatrix}
            1 \\
            1
        \end{pmatrix}, \quad i &= 1 \\
        \begin{pmatrix}
        1 & 1 \\
        1 & 0
        \end{pmatrix}
        \begin{pmatrix}
        F_{i - 1} \\
        F_{i - 2}
        \end{pmatrix}, \quad i &> 1
    \end{aligned}
\end{cases}
$$

故有

$$
\begin{pmatrix}
    F_n \\
    F_{n - 1}
\end{pmatrix} = 
\begin{pmatrix}
    1 & 1 \\
    1 & 0
\end{pmatrix}^{n - 1}
\begin{pmatrix}
    F_1 \\
    F_0
\end{pmatrix} = 
\begin{pmatrix}
    1 & 1 \\
    1 & 0
\end{pmatrix}^{n - 1}
\begin{pmatrix}
    1 \\
    1
\end{pmatrix}, \quad n > 1.
$$

由上述思想, 可以对形如 $F_i = aF_{i - 1} + bF_{i - 2}\ \; (a, b \neq 0, i > 2)$ 与 $F_i = aF_{i - 1} + i \; (a \neq 0, i > 1)$ 等递推式进行矩阵快速幂的计算.